<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[漆可的博客]]></title>
  <link href="http://qike.website/atom.xml" rel="self"/>
  <link href="http://qike.website/"/>
  <updated>2016-04-25T08:59:46+08:00</updated>
  <id>http://qike.website/</id>
  <author>
    <name><![CDATA[漆可]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[安卓使用ormlite操作数据库]]></title>
    <link href="http://qike.website/blog/2016/04/21/ormlite/"/>
    <updated>2016-04-21T23:01:20+08:00</updated>
    <id>http://qike.website/blog/2016/04/21/ormlite</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搭建博客]]></title>
    <link href="http://qike.website/blog/2016/04/21/blog/"/>
    <updated>2016-04-21T23:01:20+08:00</updated>
    <id>http://qike.website/blog/2016/04/21/blog</id>
    <content type="html"><![CDATA[<h2>1、git设置</h2>

<h4>全局配置</h4>

<blockquote><p>git config &ndash; global user.name &ldquo;qike&rdquo;</p>

<p>git -config &ndash; global user.email &ldquo;<a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#58;&#x71;&#105;&#x6b;&#101;&#x40;&#x31;&#54;&#x33;&#46;&#x63;&#x6f;&#109;">&#113;&#105;&#107;&#101;&#x40;&#x31;&#x36;&#51;&#x2e;&#x63;&#111;&#x6d;</a>&rdquo;</p></blockquote>

<h4>秘钥生成</h4>

<blockquote><p>ssh-keygen -t rsa -C &ldquo;<a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#58;&#113;&#x69;&#107;&#x65;&#x40;&#49;&#54;&#x33;&#46;&#99;&#x6f;&#109;">&#x71;&#x69;&#x6b;&#x65;&#64;&#x31;&#x36;&#51;&#46;&#x63;&#x6f;&#x6d;</a>&rdquo;</p></blockquote>

<p>检验秘钥是否有效</p>

<blockquote><p>ssh -T <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#103;&#x69;&#116;&#64;&#103;&#105;&#116;&#104;&#x75;&#98;&#x2e;&#99;&#111;&#109;">&#x67;&#x69;&#x74;&#64;&#103;&#x69;&#x74;&#x68;&#x75;&#98;&#46;&#x63;&#111;&#109;</a></p></blockquote>

<h2>2、Ruby设置</h2>

<p>分别安装好Ruby和DevKit后，需要将俩者关联起来
进入Dvkit安装目录</p>

<blockquote><p>ruby dk.rb init</p>

<p>ruby dk.rb install</p></blockquote>

<h2>3、安装Octopress</h2>

<p>克隆到本地</p>

<blockquote><p>git clone git://github.com/imathis/octopress.git octopress
cd octopress</p></blockquote>

<p>安装依赖项</p>

<blockquote><p>gem sources &ndash;add <a href="http://gems.ruby-china.org/">http://gems.ruby-china.org/</a> &ndash;remove <a href="https://rubygems.org/">https://rubygems.org/</a></p>

<p>gem source -l</p></blockquote>

<p>修改gemfile文件，将url也改成 <a href="http://gems.ruby-china.org/">http://gems.ruby-china.org/</a></p>

<blockquote><p>gem install bundler</p>

<p>bundle install</p></blockquote>

<p>安装并使用默认主题</p>

<blockquote><p>rake install</p></blockquote>

<p>生成博客</p>

<blockquote><p>rake generate</p></blockquote>

<p>预览博客</p>

<blockquote><p>rake preview</p></blockquote>

<p>1.新建博客</p>

<pre><code>rake new_post["title"]
</code></pre>

<p>2.新建单页面</p>

<pre><code>rake new_page[jikexueyuan]
</code></pre>

<p>3、文件模板</p>

<pre><code>layout: post    //post模板文件的布局
title: "ormlite"    //标题
date: 2016-04-21 23:01:20 +0800 //文字日期
comments: true  //允许评论
categories: [Android，安卓]  //分类
</code></pre>

<h2>4、部署博客到github</h2>

<pre><code>rake setup_github_pages
//需要设置url
</code></pre>

<p>每次新生成页面都要书写如下命令行
    rake deploy</p>

<h2>5、将源码托管至gitHub</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[android开发：拒绝OOM，打造自定义帧动画加载框架]]></title>
    <link href="http://qike.website/blog/2015/10/22/blog/"/>
    <updated>2015-10-22T07:01:20+08:00</updated>
    <id>http://qike.website/blog/2015/10/22/blog</id>
    <content type="html"><![CDATA[<h2>android开发：拒绝OOM，打造自定义帧动画加载框架</h2>

<p>[TOP]</p>

<blockquote><p> 转载请标明出处</p></blockquote>

<h2>一、概述</h2>

<p> 在安卓开发中，帧动画是通过逐帧显示配置在动画资源文件中的图片来实现。然而，这存在一个巨大的风险，由于安卓是一次性把动画资源文件中的所有图片资源全部加载，这就意味着如果图片数目过多，极其容易造成内存溢出。</p>

<p>那么，如何避免这种情况的发生呢。下面我们推出本文的主角SurfaceView。</p>

<h2>二、SurfaceView详解</h2>

<p>SurfaceView是一个专门用户绘制的view的子类，由于内部已做处理，并且实现了双缓冲，它可以在非UI线程中进行UI操作（谷歌仅为我们提供俩个有该特异功能的控件，另外一个是ProgressBar）。这样可以避免画图任务繁重的时候造成主线程阻塞，从而提高了程序的反应速度。广泛用于游戏开发中的绘制。</p>

<p>SurfaceView的使用非常简单,一般与SurfaceHolder结合使用：</p>

<ol>
<li><p>创建一个集成了SurfaceView的类，并实现SurfaceHolder.Callback实现后SurfaceHolder.Callback必须实现了三个方法，分别是：</p>

<blockquote><p>surfaceCreated:</p>

<p>surfaceChanged:</p>

<p>surfaceDestroyed:</p></blockquote></li>
<li>通过getHolder()获取该类的SurfaceHolder；</li>
<li>调用SurfaceHolder的addCallback(this)方法添加回调；</li>
<li>SurfaceHolder.lockCanvas()获得Canvas对象并锁定画布，该Cavas已经被自动加了同步锁；</li>
<li>利用获取Canvas的绘图方法进行绘制，本文我们是绘制bitmap；</li>
<li>SurfaceHolder.unlockCanvasAndPost(Canvas canvas)结束锁定画图，并提交改变，将图形显示。</li>
</ol>


<p>本文就是通过SurfaceView内部开启线程动态的绘制图片。</p>

<h2>三、普通方法实现帧动画</h2>

<p>先介绍下安卓原生的帧动画使用方法，废话少说，直接上代码，完整源码在文章最后提供下载地址。</p>

<p>在res目录下新建anim文件，该文件下创建frame_demo.xml文件：</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android"
android:oneshot="true" &gt;

&lt;item android:drawable="@drawable/penguin_happy_3_1"   android:duration="150"/&gt;
&lt;item android:drawable="@drawable/penguin_happy_3_2"   android:duration="150"/&gt;
&lt;item android:drawable="@drawable/penguin_happy_3_3"   android:duration="150"/&gt;
&lt;item android:drawable="@drawable/penguin_happy_3_4"   android:duration="150"/&gt;
&lt;item android:drawable="@drawable/penguin_happy_3_5"   android:duration="150"/&gt;
&lt;item android:drawable="@drawable/penguin_happy_3_6"   android:duration="150"/&gt;
&lt;item android:drawable="@drawable/penguin_happy_3_7"   android:duration="150"/&gt;
&lt;item android:drawable="@drawable/penguin_happy_3_8"   android:duration="150"/&gt;
&lt;item android:drawable="@drawable/penguin_happy_3_9"   android:duration="150"/&gt;
&lt;item android:drawable="@drawable/penguin_happy_3_10"   android:duration="150"/&gt;
&lt;item android:drawable="@drawable/penguin_happy_3_11"   android:duration="150"/&gt;
&lt;item android:drawable="@drawable/penguin_happy_3_12"   android:duration="150"/&gt;
&lt;item android:drawable="@drawable/penguin_happy_3_13"   android:duration="150"/&gt;

&lt;/animation-list&gt;
</code></pre>

<p>布局文件activity_original.xml
很简单，就是一个ImageView，scr属性为该动画资源：</p>

<pre><code>&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
xmlns:tools="http://schemas.android.com/tools"
android:layout_width="match_parent"
android:layout_height="match_parent"
tools:context="${relativePackage}.${activityClass}" &gt;

&lt;ImageView
    android:id="@+id/iv_orginal"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_centerInParent="true"
    android:src="@anim/frame_demo" /&gt;

&lt;/RelativeLayout&gt;
</code></pre>

<p>然后在activity实现动画播放：</p>

<pre><code>ImageView iv_original = (ImageView) findViewById(R.id.iv_orginal);
AnimationDrawable ani = (AnimationDrawable) iv_original.getDrawable();
ani.start();//播放动画

//打印出程序占用的内存
Log.e(TAG, Runtime.getRuntime().totalMemory()/1024 + "k");
</code></pre>

<p>以上就是安卓开发中利用普通方法实现帧动画的方式，代码很简单，我们输出该方式播放时整个应用占用的内存大小为6.08M。
<img src="http://img.blog.csdn.net/20151025211059690" alt="" /></p>

<h2>四、利用SurfaceView打造自定义帧动画播放框架</h2>

<p>首先是我们自定义的动画框架,继承自SurfaceView，
完整代码如下：</p>

<pre><code>public class FrameAnimation extends SurfaceView implements SurfaceHolder.Callback, Runnable {

private SurfaceHolder mSurfaceHolder;

private boolean mIsThreadRunning = true; // 线程运行开关
private boolean mIsDestroy = false;// 是否已经销毁

private int[] mBitmapResourceIds;// 用于播放动画的图片资源数组
private Canvas mCanvas;
private Bitmap mBitmap;// 显示的图片

private int mCurrentIndext;// 当前动画播放的位置
private int mGapTime = 150;// 每帧动画持续存在的时间

private OnFrameFinishedListener mOnFrameFinishedListener;// 动画监听事件

public FrameAnimation(Context context)
{
    this(context, null);
}

public FrameAnimation(Context context, AttributeSet attrs, int defStyle)
{
    super(context, attrs, defStyle);
    mSurfaceHolder = this.getHolder();
    mSurfaceHolder.addCallback(this);// 注册回调方法

    // 白色背景
    setZOrderOnTop(true);
    mSurfaceHolder.setFormat(PixelFormat.TRANSLUCENT);
}

public FrameAnimation(Context context, AttributeSet attrs)
{
    this(context, attrs, 0);
}

@Override
public void surfaceCreated(SurfaceHolder holder)
{
    // 创建surfaceView时启动线程
    // new Thread(this).start();
}

@Override
public void surfaceChanged(SurfaceHolder holder, int format, int width, int height)
{
}

@Override
public void surfaceDestroyed(SurfaceHolder holder)
{
    // 当surfaceView销毁时, 停止线程的运行. 避免surfaceView销毁了线程还在运行而报错.
    mIsThreadRunning = false;
    try
    {
        Thread.sleep(mGapTime);
    } catch (InterruptedException e)
    {
        e.printStackTrace();
    }

    mIsDestroy = true;
}

/**
 * 制图方法
 */
private void drawView()
{
    // 无资源文件退出
    if (mBitmapResourceIds == null)
    {
        Log.e("frameview", "the bitmapsrcIDs is null");

        mIsThreadRunning = false;

        return;
    }

    // 锁定画布
    mCanvas = mSurfaceHolder.lockCanvas();
    try
    {
        if (mSurfaceHolder != null &amp;&amp; mCanvas != null)
        {

            mCanvas.drawColor(Color.WHITE);

            // 如果图片过大可以再次对图片进行二次采样缩放处理
            mBitmap = BitmapFactory.decodeResource(getResources(), mBitmapResourceIds[mCurrentIndext]);
            mCanvas.drawBitmap(mBitmap, (getWidth() - mBitmap.getWidth()) / 2,
                    (getHeight() - mBitmap.getHeight()) / 2, null);

            // 播放到最后一张图片，停止线程
            if (mCurrentIndext == mBitmapResourceIds.length - 1)
            {
                mIsThreadRunning = false;
            }

        }
    } catch (Exception e)
    {
        e.printStackTrace();
    } finally
    {
        mCurrentIndext++;

        if (mCanvas != null)
        {
            // 将画布解锁并显示在屏幕上
            mSurfaceHolder.unlockCanvasAndPost(mCanvas);
        }

        if (mBitmap != null)
        {
            // 收回图片
            mBitmap.recycle();
        }
    }
}

@Override
public void run()
{
    if (mOnFrameFinishedListener != null)
    {
        mOnFrameFinishedListener.onStart();
    }

    // 每隔100ms刷新屏幕
    while (mIsThreadRunning)
    {
        drawView();
        try
        {
            Thread.sleep(mGapTime);
        } catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    if (mOnFrameFinishedListener != null)
    {
        mOnFrameFinishedListener.onStop();
    }
}

/**
 * 开始动画
 */
public void start()
{
    if (!mIsDestroy)
    {
        mCurrentIndext = 0;
        mIsThreadRunning = true;
        new Thread(this).start();
    } else
    {
        // 如果SurfaceHolder已经销毁抛出该异常
        try
        {
            throw new Exception("IllegalArgumentException:Are you sure the SurfaceHolder is not destroyed");
        } catch (Exception e)
        {
            e.printStackTrace();
        }
    }
}

/**
 * 设置动画播放素材
 * @param bitmapResoursIds  图片资源id
 */
public void setBitmapResoursID(int[] bitmapResourceIds)
{
    this.mBitmapResourceIds = bitmapResourceIds;
}

/**
 * 设置每帧时间
 */
public void setGapTime(int gapTime)
{
    this.mGapTime = gapTime;
}

/**
 * 结束动画
 */
public void stop()
{
    mIsThreadRunning = false;
}

/**
 * 继续动画
 */
public void reStart()
{
    mIsThreadRunning = false;
}

/**
 * 设置动画监听器
 */
public void setOnFrameFinisedListener(OnFrameFinishedListener onFrameFinishedListener)
{
    this.mOnFrameFinishedListener = onFrameFinishedListener;
}

/**
 * 动画监听器
 * @author qike
 *
 */
public interface OnFrameFinishedListener {

    /**
     * 动画开始
     */
    void onStart();

    /**
     * 动画结束
     */
    void onStop();
}

/**
 * 当用户点击返回按钮时，停止线程，反转内存溢出
 */
@Override
public boolean onKeyDown(int keyCode, KeyEvent event)
{
    // 当按返回键时，将线程停止，避免surfaceView销毁了,而线程还在运行而报错
    if (keyCode == KeyEvent.KEYCODE_BACK)
    {
        mIsThreadRunning = false;
    }

    return super.onKeyDown(keyCode, event);
}
</code></pre>

<p>}</p>

<p>布局文件activity_main.xml，同样很简单：</p>

<pre><code>&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@android:color/white"
    tools:context="${relativePackage}.${activityClass}" &gt;

&lt;com.example.frameanidemo.view.FrameAnimation
    android:id="@+id/ani_view"
    android:layout_width="match_parent"
    android:layout_height="match_parent" /&gt;

&lt;/RelativeLayout&gt;
</code></pre>

<p>最后是activity：</p>

<pre><code>public class CustomFrameActivity extends Activity {

    protected static final String TAG = "Custom";

    private FrameAnimation frameView;

    //动画资源文件
    int[] srcId =
    { R.drawable.penguin_happy_3_1, R.drawable.penguin_happy_3_2, R.drawable.penguin_happy_3_3,
        R.drawable.penguin_happy_3_4, R.drawable.penguin_happy_3_5, R.drawable.penguin_happy_3_6,
        R.drawable.penguin_happy_3_7, R.drawable.penguin_happy_3_8, R.drawable.penguin_happy_3_9,
        R.drawable.penguin_happy_3_10, R.drawable.penguin_happy_3_11, R.drawable.penguin_happy_3_12,
        R.drawable.penguin_happy_3_13 };

@Override
    protected void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        frameView = (FrameAnimation) findViewById(R.id.ani_view);
        frameView.setBitmapResoursID(srcId);

        //设置监听事件
        frameView.setOnFrameFinisedListener(new FrameAnimation.OnFrameFinishedListener() {

            @Override
            public void onStop()
            {
                Log.e(TAG, "stop");
            }

            @Override
            public void onStart()
            {
                Log.e(TAG, "start");

                Log.e(TAG, Runtime.getRuntime().totalMemory() / 1024 + "k");
            }
        });

        frameView.start();
    }
}
</code></pre>

<p>代码已经附上，看下这种方式所占的内存只有2.8M，比原生的6.08M节省了不是一丁点，这种差距尤其是在大量图片的播放中更是明显，经测试原生帧动画播放超过20张图片就非常危险，而我们自定义的与图片的多寡并无区别：
<img src="http://img.blog.csdn.net/20151025212439285" alt="自定义帧动画所占内存" /></p>

<p>源码下载：<a href="http://download.csdn.net/detail/q649381130/9212135">http://download.csdn.net/detail/q649381130/9212135</a></p>

<p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p>
]]></content>
  </entry>
  
</feed>
